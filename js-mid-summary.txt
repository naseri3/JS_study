============================================================
1) 배열 고급 패턴 (map / filter / reduce / sort / some / every)
============================================================
■ 개념
배열을 가공하고 변환하는 고급 메서드들.  
함수형 프로그래밍 스타일을 가능하게 해줌.

■ 왜 사용하는가?
- 복잡한 반복문( for / forEach )을 줄여 코드 가독성을 올림
- 데이터 정렬/검색/필터링을 “선언적 방식”으로 작성 가능
- 유지보수가 쉬워짐 → 실무에서 거의 매일 사용

■ 언제 사용하는가?
- 리스트 UI 만들 때
- 정렬, 검색 조건 처리할 때
- 데이터 통계/합계/가공이 필요할 때

■ 예제
employees
  .filter(e => e.salary > 3000)
  .map(e => e.name)
  .sort((a,b)=> a.localeCompare(b));

■ recruitSearch.js 연계
- selectedRegions.filter(), selectedJobs.filter()
- reduce로 급여 계산
- some()으로 "서울 >" 같은 prefix 검색


============================================================
2) 구조 분해(Destructuring)
============================================================
■ 개념
배열 또는 객체에서 원하는 값만 꺼내는 문법.

■ 왜 사용하는가?
- 코드 길이가 줄고 가독성 증가
- 함수 파라미터 정리 쉬움

■ 언제 사용하는가?
- 객체에서 name, salary 같은 특정 값만 필요할 때
- API 응답 처리 시 매우 자주 사용

■ 예제
const { name, age } = user;


============================================================
3) 클로저(Closure)
============================================================
■ 개념
“내부 함수가 외부 함수의 변수에 계속 접근할 수 있는 기능”.

■ 왜 사용하는가?
- 상태(State) 저장
- 전역 변수 없이 데이터 은닉 가능 (캡슐화)
- 모듈 패턴 구현에 핵심


■ 언제 사용하는가?
- 이벤트에서 외부 값 기억 필요할 때
- 모듈 내부 데이터 보호할 때

■ 예제
function counter() {
  let value = 0;
  return {
    inc() { value++; },
    get() { return value; }
  };
}

■ recruitSearch.js 연계
lowerBtn.onclick = () => handleLowerClick(upperName, ...);
// 클릭할 때 upperName을 기억함 → 클로저가 쓰임


============================================================
4) 고차 함수(HOF) & 동적 정렬
============================================================
■ 개념
함수를 인자로 받거나 함수를 반환하는 함수.

■ 왜 사용하는가?
- 정렬 기준을 동적으로 만듦
- 코드 재사용 극대화

■ 언제 사용하는가?
- name, salary 등 정렬 기준이 여러 개일 때
- 함수에 “설정값”을 미리 적용하고 싶을 때 (커링)

■ 예제: 동적 정렬
const sortBy = key => (a,b) => (a[key] > b[key] ? 1 : -1);
employees.sort(sortBy("salary"));
employees.sort(sortBy("name"));


============================================================
5) 커링(Currying)
============================================================
■ 개념
여러 개의 인수를 받는 함수를 “1개씩 받는 함수”로 나눈 것.

■ 왜 사용하는가?
- 함수 재사용성 ↑
- 미리 설정값을 넣어둔 함수 만들기 쉬움

■ 언제 사용하는가?
- 필터 조건을 재활용하고 싶을 때
- API 기본 URL/토큰 저장하고 재활용할 때

■ 예제
const multiply = a => b => c => a * b * c;


============================================================
6) 재귀 함수(Recursive)
============================================================
■ 개념
자기 자신을 호출하는 함수.

■ 왜 사용하는가?
- 중첩 구조(트리) 탐색에 강함
- 메뉴/카테고리/코멘트 같은 계층 구조 처리

■ 언제 사용하는가?
- 무한 depth 구조 탐색
- DFS(깊이 우선 탐색) 알고리즘

■ 예제
function factorial(n) {
  return n === 1 ? 1 : n * factorial(n - 1);
}


============================================================
7) 체이닝(Chaining)
============================================================
■ 개념
함수가 값을 반환하고, 그 반환값에 다시 연속해서 메서드 호출하는 패턴.

■ 왜 사용하는가?
- 가독성 좋음
- 복잡한 데이터 처리 로직을 한 흐름으로 표현

■ 예제
employees
  .filter(...)
  .map(...)
  .sort(...);


============================================================
8) 즉시 실행 함수(IIFE) + 모듈 스코프 보호
============================================================
■ 개념
정의되자마자 즉시 실행되는 함수.

■ 왜 사용하는가?
- 전역 변수 오염 방지
- 모듈 내부 데이터 보호 (캡슐화)

■ 언제 사용하는가?
- 라이브러리 초기화
- 모듈 패턴 구현

■ 예제
const App = (function() {
  let data = [];
  return {
    add(x) { data.push(x); },
    get list() { return [...data]; }
  };
})();


============================================================
9) 클래스 & 상속 (Class & Inheritance)
============================================================
■ 개념
객체를 생성하는 틀(설계도)  
상속 extends 로 부모 기능을 물려받음.

■ 왜 사용하는가?
- 복잡한 객체 설계를 체계화
- 대규모 프로젝트에서 유지보수 편함

■ 언제 사용하는가?
- 직원, 상품, 주문, 캐릭터처럼 동일한 구조의 객체가 반복될 때
- 게임, UI 컴포넌트, 데이터 모델

■ 예제
class Employee {
  constructor(name, salary) {
    this.name = name;
    this.salary = salary;
  }
}

class Manager extends Employee {
  constructor(name, salary, team) {
    super(name, salary);
    this.team = team;
  }
}


============================================================
10) this 바인딩
============================================================
■ 개념
함수가 실행되는 문맥(Context)을 의미.

■ 왜 사용하는가?
- 이벤트 핸들러, 객체 메서드, 클래스 등에서 동작 방식이 다름

■ 언제 사용하는가?
- 객체 메서드 정의 시
- DOM 이벤트 처리 시

■ 예제
button.addEventListener("click", function() {
  console.log(this); // 버튼 요소
});


============================================================
11) 모듈 패턴 정리 (recruitSearch.js 구조와 동일)
============================================================
■ 개념
클로저 + IIFE를 이용해 데이터 은닉 + 공개 API 제공.

■ 왜 사용하는가?
- 전역 변수 없이 상태를 관리할 수 있음
- 안전한 코드 구조 제공

■ 예제
const RegionModule = (function() {
  let regions = [];
  return {
    add(r) { regions.push(r); },
    list() { return [...regions]; }
  };
})();


============================================================
12) 실전 예제: 직원 관리기 (클로저 + 모듈 + 고급 메서드)
============================================================
function createEmployeeManager() {
  let list = [];
  return {
    add(emp) {
      list.push(emp);
      return list.length;
    },
    remove(id) {
      list = list.filter(e => e.id !== id);
    },
    findByName(name) {
      return list.find(e => e.name === name);
    },
    get totalSalary() {
      return list.reduce((sum, e) => sum + e.salary, 0);
    },
  };
}

============================================================
이 문서는 중급 + 상급 JS 개념을 실제 개발에서
언제, 왜 사용하는지 중심으로 구성한 실전 안내서입니다.
============================================================
