=====================================================
📌 JavaScript Loop Patterns — 실무 기준 이론 정리
(for / for...in / for...of / forEach)
=====================================================

이 문서는 단순 문법 비교가 아니라,
👉 "왜 이 반복문을 선택해야 하는가?" 를 기준으로 설계됨.

loop 선택 기준 핵심:

1) 데이터의 구조가 무엇인가? (배열 / 객체 / iterable / NodeList / JSON)
2) 중단(break/continue)이 필요한가?
3) 성능이 중요한가?
4) 유지보수/가독성이 중요한가?
5) 비동기 처리(await/useEffect 등)와 섞여 쓰는가?

-----------------------------------------------------
1) for (기본 루프)
-----------------------------------------------------

[개념]
- 가장 원초적인 반복문. 인덱스를 기반으로 동작.
- 성능 면에서는 배열 순회 중 가장 빠른 구조 중 하나.

[언제 사용?]
✔ break, continue가 필요한 경우  
✔ 배열 인덱스를 직접 제어해야 하는 경우  
✔ 긴 데이터, 대량 데이터 처리(성능 중요)  

[왜 사용하는가?]
- "가장 제어력이 높은 반복문" → 필요한 만큼 정밀하게 제어 가능

[실무 예시]
- 검색 결과 스크롤 페이징 처리
- 데이터 전처리(3만 개 이상 처리, 성능 중요)
- React 렌더링 전 데이터 reshape

[예제]
for (let i = 0; i < list.length; i++) {
  if(list[i].isDeleted) continue;
  // 처리 로직
}

=> "변환 + 조건 + 중지 + 최적화" 같은 복합 로직에 적합.

-----------------------------------------------------
2) for...in (객체 전용 순회)
-----------------------------------------------------

[개념]
- 객체의 key를 순회하는 반복문.

[언제 사용?]
✔ 객체의 속성(key/value)을 조사할 때  
✔ 데이터 구조 변경, 동적 필드 추출  
✔ JSON 구조 분석 또는 서버 데이터 디버깅

[왜 사용하는가?]
- 객체의 "키 기반 접근"이 목적일 때 가장 자연스러운 반복문.

⚠ 주의점:
- 배열에 사용하면 인덱스 순서를 보장하지 않음.
- prototype 체인에 있는 값까지 순회될 수 있어 `hasOwnProperty` 필수.

[실무 예시]
- API 응답 구조 파악
- 폼 데이터 자동 생성
- config 옵션 자동 바인딩

[예제]
for (const key in company) {
  if (!Object.prototype.hasOwnProperty.call(company, key)) continue;
  console.log(key, company[key]);
}

=> "객체 기반 데이터 확인 및 동적 처리"

-----------------------------------------------------
3) for...of (iterable 전용 순회)
-----------------------------------------------------

[개념]
- 배열/문자열/Map/Set/NodeList 등 "iterable" 항목을 순회.

[언제 사용?]
✔ 배열 요소 중심 작업  
✔ index보다 value가 중요한 경우  
✔ 가독성이 중요하고 break/continue가 필요한 경우

[왜 사용하는가?]
- forEach보다 가독성 높고
- break/continue도 가능 → 실무에서 선호도 상승.

[실무 예시]
- API 데이터 출력 → DOM/UI 처리
- NodeList 쿼리 후 반복 처리(document.querySelectorAll)
- React 컨텍스트 없이 일반 JS 로직 짤 때

[예제]
for(const user of users){
  if(!user.active) continue;
  console.log(user.name);
}

=> "배열 기반 데이터 처리 시 가장 이상적인 균형형 반복문"

-----------------------------------------------------
4) forEach (함수형 스타일 반복문)
-----------------------------------------------------

[개념]
- 배열 전용 메서드로, 콜백 기반 실행.
- break/return으로 반복 중단 불가능(중단 불가 구조)

[언제 사용?]
✔ 순수 데이터 순회 + 결과 처리  
✔ 사이드 이펙트(로그, DOM 조작 등)가 목적일 때  
✔ 함수형 프로그래밍 mindset 필요할 때  

[왜 사용하는가?]
- "무조건 전부 돌리는 구조" → 선언적, 의존성 적음.
- 의도: "나는 이 배열을 한 바퀴 돌릴 거야" → 명확함.

⚠ 단점:
- async/await와 함께 쓰면 의도대로 동작하지 않는 경우 많음.

[실무 예시]
- UI 업데이트 루프
- 로깅/모니터링
- 이벤트 핸들링 집합 실행

[예제]
users.forEach(user => {
  console.log(`로그 기록: ${user.name}`);
});

=> "중단 필요없는 사이드 이펙트 중심 반복문"

-----------------------------------------------------
📌 실무 선택 기준 요약

| 기준 | 가장 적합한 반복문 |
|------|-------------------|
| 대용량 데이터 성능 | for |
| 값 중심 단순 반복 | for...of |
| 객체 key 순회 | for...in |
| 선언형, UI 로그, DOM 순회 | forEach |
| break/continue 필요 | for 또는 for...of |
| async/await 사용 | for 또는 for...of |
| 배열+가독성 최적 | for...of |
| 함수형 코드 스타일 | forEach |

-----------------------------------------------------

📌 실무 패턴 예시

// 비동기 처리 + 반복문 올바른 예 (forEach는 금지)
async function processJobs(posts){
  for(const post of posts){
    await saveToDB(post);
  }
}

-----------------------------------------------------

📌 개발자 레벨별 요약

Junior → "반복문 선택 기준 없음"  
Mid → "for / forEach 구분해서 사용"  
Senior → "데이터 구조 + 유지보수 + 성능 고려해 반복문 선택"




=====================================================
📌 JavaScript 중급 · 고급 개념 정리 (실무 중심)
=====================================================

작성 목적:
- 단순 문법 암기가 아니라 "언제/왜/어디서" 사용하는지 이해
- 유지보수, 확장성, 실무 구조 설계 중심 사고 습득
- React/Next.js/TypeScript 전환 준비 기반

--------------------------------------------
1) Scope (스코프) & Execution Context (실행 컨텍스트)
--------------------------------------------

[개념]
- 변수, 함수, 객체가 접근 가능한 범위.
- 종류: 전역(Global), 함수(Function), 블록(Block - let,const)

[왜 필요한가]
- 변수 충돌 방지
- 코드 구조를 역할별로 나눌 수 있음

[언제 사용되는가]
- 함수 기반 로직 설계
- 이벤트, API 호출, 컴포넌트 상태 관리

[실무 활용 사례]
- "같은 변수명이어도 영역이 다르면 충돌 방지 → 유지보수 쉬움"

[짧은 예제]
function createCounter() {
  let count = 0;
  return function() {
    count++;
    console.log(count);
  }
}

const run = createCounter();
run(); //1
run(); //2



--------------------------------------------
2) Closure (클로저)
--------------------------------------------

[개념]
- 함수가 선언될 당시의 스코프를 기억하여 외부에서도 내부 변수를 유지할 수 있는 구조.

[왜 필요한가]
- Private 변수 유지
- 상태(state) 저장
- 외부 접근을 제한해 안전성↑

[언제 사용되는가]
- 로그인 세션 유지
- 데이터 캐싱
- throttle / debounce (scroll 이벤트 최적화)

[실무 활용]
- 상태 기반 UI/UX 처리를 할 때 필수

[짧은 예제]
function storeUsername() {
  let username = "NaSeul";
  return () => console.log(username);
}

const showUser = storeUsername();
showUser(); // NaSeul



--------------------------------------------
3) Higher-Order Function (고차 함수)
--------------------------------------------

[개념]
- 함수를 인자로 받거나 반환하는 함수

[왜 사용?]
- 반복적인 로직을 추상화
- 코드 재사용성 증가
- 유지보수 및 가독성 향상

[언제 사용?]
- 배열 처리(map, filter, reduce)
- 미들웨어 패턴
- 비동기 이벤트 연결

[실무 활용 예]
const salaries = [1200000, 1800000, 2500000];
const formatted = salaries.map(v => `${v.toLocaleString()}원`);



--------------------------------------------
4) 배열 메서드 체이닝 (map → filter → reduce)
--------------------------------------------

[개념]
여러 배열 메서드를 연결해 데이터를 가공하는 패턴

[왜 사용?]
- 가독성 좋고 효율적
- SQL 또는 Functional Programming 느낌의 데이터 처리 가능

[실무 활용 사례]
- API → 데이터 필터링 → UI 렌더링

[예제]
const result = users
  .filter(u => u.role === "관리자")
  .sort((a,b) => b.score - a.score)
  .map(u => u.name);



--------------------------------------------
5) Destructuring (구조 분해 할당)
--------------------------------------------

[개념]
- 객체/배열의 값을 변수로 간단히 꺼내는 방법

[왜 사용?]
- API 응답 처리 시 필수
- React Hooks와 필수 조합

[실무 예제]
const { title, region, company } = jobPost;



--------------------------------------------
6) Spread / Rest (... 연산자)
--------------------------------------------

[개념]
- Spread: 복사/병합
- Rest: 남은 값들을 묶어서 처리

[왜 필요한가]
- 불변성 유지 (React 상태 관리 핵심)

[실무 예제]
const updated = { ...post, views: post.views + 1 };



--------------------------------------------
7) async/await + Promise (비동기 처리)
--------------------------------------------

[개념]
- 비동기 실행 흐름을 동기처럼 표현하는 방식

[왜 필요한가]
- callback hell 방지
- UI 비동기 요청 처리에 필수

[사용 사례]
- 로그인, DB 조회, 파일 업로드, API 요청

[짧은 예제]
async function getJobs() {
  const res = await fetch("/api/jobs");
  return await res.json();
}



--------------------------------------------
8) try/catch (에러 처리)
--------------------------------------------

[이유]
- 사용자 경험 보호
- 실패 상태를 제어 가능

[예제]
try {
  await submitForm();
} catch(error) {
  showToast("저장 실패. 다시 시도해주세요.");
}



--------------------------------------------
9) Module (모듈화) & 파일 구조 설계
--------------------------------------------

[개념]
- 코드를 기능별로 나누어 import/export 구조 구성

[왜 필요한가]
- 협업 구조
- 유지보수 효율
- React/Vue 프레임워크 기반 구조 정착

[예시 파일 구조]
/services/api.js
/utils/format.js
/components/jobCard.js



--------------------------------------------
10) Class 기반 설계 패턴
--------------------------------------------

[개념]
- 객체 설계 틀(설계도)

[왜 사용?]
- 반복되는 UI 구조나 로직 패턴화

[실무 패턴 예제]
class JobCard {
  constructor(data) {
    this.data = data;
  }

  render() {
    return `<div>${this.data.title}</div>`;
  }
}



=====================================================
🔥 실무 사고 방식 템플릿
=====================================================

✔ 이 로직은 왜 이렇게 구성했는가?  
✔ 다른 방식과 비교하면 장단점은?  
✔ 유지보수/확장 가능한 구조인가?  
✔ React/Vue 프레임워크 적용 시 문제 없는가?  
✔ 팀원이 봐도 이해 쉬운가?

=====================================================
끝.
=====================================================
